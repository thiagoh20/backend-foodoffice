name: Deploy Backend

on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20'

jobs:
  # test:
  #   name: Ejecutar tests y verificaciones
  #   runs-on: ubuntu-latest
    
  #   steps:
  #     - name: Checkout c√≥digo
  #       uses: actions/checkout@v4

  #     - name: Configurar Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: ${{ env.NODE_VERSION }}
  #         cache: 'npm'

  #     - name: Instalar dependencias
  #       run: npm ci

  #     - name: Verificar tipos TypeScript
  #       run: npm run check

  #     - name: Ejecutar tests
  #       run: npm test

  #     - name: Construir proyecto
  #       run: npm run build

  deploy:
    name: Desplegar a AWS
    runs-on: ubuntu-latest
    environment: aws
    # needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4

      - name: Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Instalar dependencias
        run: npm ci

      - name: Construir proyecto
        run: npm run build

      - name: Instalar AWS SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Configurar credenciales AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Construir con SAM
        run: |
          export PATH="$PATH:$(pwd)/node_modules/.bin"
          sam build

      - name: Desplegar con SAM
        run: |
          sam deploy \
            --parameter-overrides \
              DatabaseHost="${{ secrets.DATABASE_HOST }}" \
              DatabaseName="${{ secrets.DATABASE_NAME }}" \
              DatabaseUser="${{ secrets.DATABASE_USER }}" \
              DatabasePassword="${{ secrets.DATABASE_PASSWORD }}" \
              JwtSecret="${{ secrets.JWT_SECRET }}" \
              SubnetIds="${{ secrets.SUBNET_IDS }}" \
              SecurityGroupId="${{ secrets.SECURITY_GROUP_ID }}" \
              AllowedOrigins="${{ secrets.ALLOWED_ORIGINS }}" \
              OAuthServerUrl="${{ secrets.OAUTH_SERVER_URL }}" \
              ViteAppId="${{ secrets.VITE_APP_ID }}" \
              OAuthClientSecret="${{ secrets.OAUTH_CLIENT_SECRET }}" \
              OwnerOpenId="${{ secrets.OWNER_OPEN_ID }}" \
            --no-confirm-changeset \
            --no-fail-on-empty-changeset

      - name: Obtener URL de la API
        id: get-api-url
        run: |
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name foodoffice-backend \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
            --output text)
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "API desplegada en: $API_URL"

      - name: Verificar y Configurar Security Groups
        run: |
          echo "üîç Verificando configuraci√≥n de Security Groups..."
          
          LAMBDA_SG="${{ secrets.SECURITY_GROUP_ID }}"
          RDS_SG="${{ secrets.RDS_SECURITY_GROUP_ID }}"
          
          # Valores conocidos de Terraform (dev environment)
          # Si RDS_SECURITY_GROUP_ID no est√° configurado, intentar usar valores conocidos
          if [ -z "$RDS_SG" ]; then
            echo "‚ö†Ô∏è  RDS_SECURITY_GROUP_ID no est√° configurado en los secrets."
            echo ""
            echo "üí° Intentando usar valores conocidos de Terraform (dev environment)..."
            echo "   Lambda SG: $LAMBDA_SG"
            echo "   RDS SG (asumido): sg-05ab21fca371a7df5"
            echo ""
            echo "üìã Si estos valores no son correctos, configura RDS_SECURITY_GROUP_ID en los secrets."
            echo ""
            
            # Usar valor conocido de Terraform para dev
            RDS_SG="sg-05ab21fca371a7df5"
            echo "üîß Usando RDS Security Group: $RDS_SG"
          else
            echo "‚úÖ RDS_SECURITY_GROUP_ID configurado: $RDS_SG"
          fi
          
          echo "üîç Verificando y configurando Security Groups..."
          echo "   Lambda Security Group: $LAMBDA_SG"
          echo "   RDS Security Group: $RDS_SG"
          
          # Verificar Lambda Security Group (Egress)
          echo "1Ô∏è‚É£  Verificando Lambda Security Group (Egress)..."
          LAMBDA_OUTBOUND=$(aws ec2 describe-security-groups \
            --group-ids $LAMBDA_SG \
            --query 'SecurityGroups[0].IpPermissionsEgress[?FromPort==`5432` && ToPort==`5432` && IpProtocol==`tcp`]' \
            --output json 2>/dev/null || echo "[]")
          
          # Verificar si permite hacia RDS espec√≠ficamente
          ALLOWS_RDS=$(echo "$LAMBDA_OUTBOUND" | jq -r '.[] | select(.UserIdGroupPairs[].GroupId == "'$RDS_SG'") | .UserIdGroupPairs[].GroupId' 2>/dev/null || echo "")
          
          if [ -z "$ALLOWS_RDS" ]; then
            echo "‚ö†Ô∏è  Lambda Security Group NO permite tr√°fico saliente al puerto 5432 hacia RDS"
            echo "üí° Nota: Terraform cre√≥ los Security Groups, pero las reglas de tr√°fico deben configurarse por separado."
            echo "üîß Intentando configurar autom√°ticamente..."
            
            if aws ec2 authorize-security-group-egress \
              --group-id $LAMBDA_SG \
              --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,UserIdGroupPairs=[{GroupId=$RDS_SG}] 2>/dev/null; then
              echo "‚úÖ Regla de salida configurada exitosamente"
              echo "   Lambda ($LAMBDA_SG) ‚Üí RDS ($RDS_SG) en puerto 5432"
            else
              ERROR=$(aws ec2 authorize-security-group-egress \
                --group-id $LAMBDA_SG \
                --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,UserIdGroupPairs=[{GroupId=$RDS_SG}] 2>&1)
              
              if echo "$ERROR" | grep -q "already exists"; then
                echo "‚úÖ La regla ya existe (configurada de otra manera)"
              else
                echo "‚ùå No se pudo configurar autom√°ticamente."
                echo ""
                echo "üìã Configura manualmente ejecutando:"
                echo "   aws ec2 authorize-security-group-egress \\"
                echo "     --group-id $LAMBDA_SG \\"
                echo "     --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,UserIdGroupPairs=[{GroupId=$RDS_SG}]"
                echo ""
                echo "üí° O agrega esta regla en el c√≥digo de Terraform para que se configure autom√°ticamente."
                exit 1
              fi
            fi
          else
            echo "‚úÖ Lambda Security Group permite tr√°fico saliente al puerto 5432 hacia RDS"
          fi
          
          # Verificar RDS Security Group (Ingress)
          echo "2Ô∏è‚É£  Verificando RDS Security Group (Ingress)..."
          RDS_INBOUND=$(aws ec2 describe-security-groups \
            --group-ids $RDS_SG \
            --query 'SecurityGroups[0].IpPermissions[?FromPort==`5432` && ToPort==`5432` && IpProtocol==`tcp`]' \
            --output json 2>/dev/null || echo "[]")
          
          echo "   Reglas de entrada encontradas:"
          echo "$RDS_INBOUND" | jq '.' 2>/dev/null || echo "$RDS_INBOUND"
          
          # Verificar si permite desde Lambda espec√≠ficamente
          ALLOWS_LAMBDA=$(echo "$RDS_INBOUND" | jq -r '.[] | select(.UserIdGroupPairs[].GroupId == "'$LAMBDA_SG'") | .UserIdGroupPairs[].GroupId' 2>/dev/null || echo "")
          
          if [ -z "$ALLOWS_LAMBDA" ]; then
            echo "‚ö†Ô∏è  RDS Security Group NO permite tr√°fico entrante desde Lambda ($LAMBDA_SG) en el puerto 5432"
            echo "üí° Nota: Terraform cre√≥ los Security Groups, pero las reglas de tr√°fico deben configurarse por separado."
            echo "üîß Intentando configurar autom√°ticamente..."
            
            if aws ec2 authorize-security-group-ingress \
              --group-id $RDS_SG \
              --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,UserIdGroupPairs=[{GroupId=$LAMBDA_SG}] 2>/dev/null; then
              echo "‚úÖ Regla de entrada configurada exitosamente"
              echo "   Lambda ($LAMBDA_SG) ‚Üí RDS ($RDS_SG) en puerto 5432"
            else
              ERROR=$(aws ec2 authorize-security-group-ingress \
                --group-id $RDS_SG \
                --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,UserIdGroupPairs=[{GroupId=$LAMBDA_SG}] 2>&1)
              
              if echo "$ERROR" | grep -q "already exists"; then
                echo "‚úÖ La regla ya existe (puede estar configurada de otra manera)"
                echo "   Verificando nuevamente..."
                # Verificar nuevamente despu√©s del intento
                RDS_INBOUND_NEW=$(aws ec2 describe-security-groups \
                  --group-ids $RDS_SG \
                  --query 'SecurityGroups[0].IpPermissions[?FromPort==`5432` && ToPort==`5432` && IpProtocol==`tcp`]' \
                  --output json 2>/dev/null || echo "[]")
                ALLOWS_LAMBDA_NEW=$(echo "$RDS_INBOUND_NEW" | jq -r '.[] | select(.UserIdGroupPairs[].GroupId == "'$LAMBDA_SG'") | .UserIdGroupPairs[].GroupId' 2>/dev/null || echo "")
                if [ -n "$ALLOWS_LAMBDA_NEW" ]; then
                  echo "‚úÖ Confirmado: RDS permite tr√°fico desde Lambda"
                else
                  echo "‚ö†Ô∏è  La regla existe pero no permite espec√≠ficamente desde Lambda Security Group"
                  echo "   Puede que permita desde cualquier IP (0.0.0.0/0) o desde otro Security Group"
                fi
              else
                echo "‚ùå No se pudo configurar autom√°ticamente."
                echo "   Error: $ERROR"
                echo ""
                echo "üìã Configura manualmente ejecutando:"
                echo "   aws ec2 authorize-security-group-ingress \\"
                echo "     --group-id $RDS_SG \\"
                echo "     --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,UserIdGroupPairs=[{GroupId=$LAMBDA_SG}]"
                echo ""
                echo "üí° O agrega esta regla en el c√≥digo de Terraform para que se configure autom√°ticamente."
                exit 1
              fi
            fi
          else
            echo "‚úÖ RDS Security Group permite tr√°fico entrante desde Lambda ($LAMBDA_SG) en puerto 5432"
          fi
          
          echo ""
          echo "‚úÖ Security Groups configurados correctamente"
          echo "   Las reglas de tr√°fico entre Lambda y RDS est√°n activas"
          
          # Verificaci√≥n final detallada
          echo ""
          echo "üîç Verificaci√≥n final de Security Groups:"
          echo "   Lambda SG ($LAMBDA_SG) - Egress hacia RDS:"
          aws ec2 describe-security-groups \
            --group-ids $LAMBDA_SG \
            --query 'SecurityGroups[0].IpPermissionsEgress[?FromPort==`5432` && ToPort==`5432` && IpProtocol==`tcp`]' \
            --output json 2>/dev/null | jq '.' || echo "   No se pudo verificar"
          
          echo "   RDS SG ($RDS_SG) - Ingress desde Lambda:"
          aws ec2 describe-security-groups \
            --group-ids $RDS_SG \
            --query 'SecurityGroups[0].IpPermissions[?FromPort==`5432` && ToPort==`5432` && IpProtocol==`tcp`]' \
            --output json 2>/dev/null | jq '.' || echo "   No se pudo verificar"

      - name: Diagn√≥stico de configuraci√≥n de Lambda
        run: |
          echo "üîç Diagn√≥stico de configuraci√≥n de Lambda..."
          
          LAMBDA_SG="${{ secrets.SECURITY_GROUP_ID }}"
          
          # Obtener nombre de la funci√≥n Lambda
          LAMBDA_FUNCTION=$(aws lambda list-functions \
            --query 'Functions[?contains(FunctionName, `foodoffice-backend`) && contains(FunctionName, `ApiFunction`)].FunctionName' \
            --output text 2>/dev/null | head -1)
          
          if [ -z "$LAMBDA_FUNCTION" ]; then
            echo "‚ö†Ô∏è  No se encontr√≥ la funci√≥n Lambda"
            exit 0
          fi
          
          echo "‚úÖ Funci√≥n Lambda: $LAMBDA_FUNCTION"
          echo ""
          
          # Verificar configuraci√≥n de VPC
          echo "1Ô∏è‚É£  Verificando configuraci√≥n de VPC de Lambda..."
          VPC_CONFIG=$(aws lambda get-function-configuration \
            --function-name "$LAMBDA_FUNCTION" \
            --query 'VpcConfig' \
            --output json 2>/dev/null)
          
          LAMBDA_SGS=$(echo "$VPC_CONFIG" | jq -r '.SecurityGroupIds[]?' 2>/dev/null || echo "")
          LAMBDA_SUBNETS=$(echo "$VPC_CONFIG" | jq -r '.SubnetIds[]?' 2>/dev/null || echo "")
          LAMBDA_VPC_ID=$(echo "$VPC_CONFIG" | jq -r '.VpcId' 2>/dev/null || echo "")
          
          echo "Security Groups configurados en Lambda:"
          echo "$LAMBDA_SGS" | while read SG; do
            if [ -n "$SG" ]; then
              if [ "$SG" == "$LAMBDA_SG" ]; then
                echo "  ‚úÖ $SG (correcto)"
              else
                echo "  ‚ö†Ô∏è  $SG (esperado: $LAMBDA_SG)"
              fi
            fi
          done
          
          echo ""
          echo "Subnets configuradas:"
          echo "$LAMBDA_SUBNETS" | while read SUBNET; do
            if [ -n "$SUBNET" ]; then
              echo "  - $SUBNET"
            fi
          done
          
          echo ""
          echo "VPC ID: $LAMBDA_VPC_ID"
          echo ""
          
          # Verificar DATABASE_URL
          echo "2Ô∏è‚É£  Verificando DATABASE_URL..."
          DATABASE_URL=$(aws lambda get-function-configuration \
            --function-name "$LAMBDA_FUNCTION" \
            --query 'Environment.Variables.DATABASE_URL' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$DATABASE_URL" ] && [ "$DATABASE_URL" != "None" ]; then
            DB_HOST=$(echo "$DATABASE_URL" | sed -n 's/.*@\([^:]*\):.*/\1/p')
            echo "‚úÖ DATABASE_URL configurado"
            echo "   Host: $DB_HOST"
            
            if echo "$DB_HOST" | grep -q "\.rds\.amazonaws\.com"; then
              echo "   ‚úÖ Hostname parece ser un endpoint de RDS"
            else
              echo "   ‚ö†Ô∏è  Hostname no parece ser un endpoint de RDS"
            fi
          else
            echo "‚ùå DATABASE_URL NO est√° configurado"
          fi
          echo ""
          
          # Verificar logs recientes
          echo "3Ô∏è‚É£  Revisando logs recientes de Lambda..."
          LOG_GROUP="/aws/lambda/$LAMBDA_FUNCTION"
          
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text 2>/dev/null | grep -q "$LOG_GROUP"; then
            echo "√öltimos errores relacionados con base de datos:"
            aws logs tail "$LOG_GROUP" --since 30m --format short 2>/dev/null | \
              grep -i "error\|database\|connection\|timeout\|ECONNREFUSED\|ENOTFOUND\|Failed query" | \
              tail -10 || echo "   No se encontraron errores recientes"
          else
            echo "‚ö†Ô∏è  No se encontr√≥ el log group"
          fi

      - name: Esperar propagaci√≥n de cambios
        run: |
          echo "‚è≥ Esperando 30 segundos para que los cambios de Security Groups se propaguen..."
          echo "   Los cambios en Security Groups pueden tardar hasta 30 segundos en aplicarse"
          sleep 30

      - name: Verificar conexi√≥n a base de datos
        run: |
          echo "üîç Verificando conexi√≥n a la base de datos..."
          
          API_URL="${{ steps.get-api-url.outputs.api_url }}"
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Intento $i/$MAX_RETRIES..."
            
            RESPONSE=$(curl -s -w "\n%{http_code}" "$API_URL/api/db-check" || echo "")
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" == "200" ]; then
              SUCCESS=$(echo "$BODY" | jq -r '.success' 2>/dev/null || echo "false")
              
              if [ "$SUCCESS" == "true" ]; then
                echo "‚úÖ Conexi√≥n a la base de datos exitosa"
                echo "$BODY" | jq '.'
                
                # Verificar si las tablas existen
                TABLES_EXIST=$(echo "$BODY" | jq -r '.tablesExist' 2>/dev/null || echo "false")
                if [ "$TABLES_EXIST" == "true" ]; then
                  echo "‚úÖ Las tablas existen en la base de datos"
                else
                  echo "‚ö†Ô∏è  Las tablas no existen. Se ejecutar√°n las migraciones."
                fi
                
                exit 0
              else
                ERROR=$(echo "$BODY" | jq -r '.error' 2>/dev/null || echo "Error desconocido")
                echo "‚ùå Error en la conexi√≥n: $ERROR"
                
                # Detectar si es un error de Security Groups
                if echo "$ERROR" | grep -q "timeout\|ECONNREFUSED\|Failed query"; then
                  echo ""
                  echo "üî¥ PROBLEMA DETECTADO: Probablemente los Security Groups no est√°n configurados"
                  echo ""
                  echo "üìã Soluci√≥n:"
                  echo "   1. Agrega el secret RDS_SECURITY_GROUP_ID en GitHub Actions"
                  echo "   2. O configura manualmente los Security Groups:"
                  echo ""
                  echo "   # Lambda Security Group (Egress)"
                  echo "   aws ec2 authorize-security-group-egress \\"
                  echo "     --group-id ${{ secrets.SECURITY_GROUP_ID }} \\"
                  echo "     --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,UserIdGroupPairs=[{GroupId=<RDS_SG_ID>}]"
                  echo ""
                  echo "   # RDS Security Group (Ingress)"
                  echo "   aws ec2 authorize-security-group-ingress \\"
                  echo "     --group-id <RDS_SG_ID> \\"
                  echo "     --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,UserIdGroupPairs=[{GroupId=${{ secrets.SECURITY_GROUP_ID }}}]"
                  echo ""
                fi
                
                # Mostrar troubleshooting si est√° disponible
                TROUBLESHOOTING=$(echo "$BODY" | jq -r '.troubleshooting[]?' 2>/dev/null || echo "")
                if [ -n "$TROUBLESHOOTING" ]; then
                  echo "üí° Troubleshooting:"
                  echo "$TROUBLESHOOTING" | while read line; do
                    echo "   - $line"
                  done
                fi
                
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "‚è≥ Reintentando en $RETRY_DELAY segundos..."
                  sleep $RETRY_DELAY
                else
                echo ""
                echo "‚ùå No se pudo conectar a la base de datos despu√©s de $MAX_RETRIES intentos"
                echo ""
                echo "üîç DIAGN√ìSTICO DETALLADO:"
                echo ""
                
                LAMBDA_FUNCTION=$(aws lambda list-functions \
                  --query 'Functions[?contains(FunctionName, `foodoffice-backend`) && contains(FunctionName, `ApiFunction`)].FunctionName' \
                  --output text 2>/dev/null | head -1)
                
                if [ -z "$LAMBDA_FUNCTION" ]; then
                  echo "‚ùå No se encontr√≥ la funci√≥n Lambda"
                  exit 1
                fi
                
                LAMBDA_SG="${{ secrets.SECURITY_GROUP_ID }}"
                RDS_SG="${{ secrets.RDS_SECURITY_GROUP_ID }}"
                if [ -z "$RDS_SG" ]; then
                  RDS_SG="sg-05ab21fca371a7df5"
                fi
                
                echo "1Ô∏è‚É£  Configuraci√≥n de VPC de Lambda:"
                VPC_CONFIG=$(aws lambda get-function-configuration \
                  --function-name "$LAMBDA_FUNCTION" \
                  --query 'VpcConfig' \
                  --output json 2>/dev/null)
                
                LAMBDA_SGS_ACTUAL=$(echo "$VPC_CONFIG" | jq -r '.SecurityGroupIds[]?' 2>/dev/null || echo "")
                LAMBDA_SUBNETS=$(echo "$VPC_CONFIG" | jq -r '.SubnetIds[]?' 2>/dev/null || echo "")
                LAMBDA_VPC_ID=$(echo "$VPC_CONFIG" | jq -r '.VpcId' 2>/dev/null || echo "")
                
                echo "   Funci√≥n: $LAMBDA_FUNCTION"
                echo "   VPC ID: $LAMBDA_VPC_ID"
                echo "   Security Groups configurados:"
                echo "$LAMBDA_SGS_ACTUAL" | while read SG; do
                  if [ -n "$SG" ]; then
                    if [ "$SG" == "$LAMBDA_SG" ]; then
                      echo "     ‚úÖ $SG (correcto)"
                    else
                      echo "     ‚ö†Ô∏è  $SG (esperado: $LAMBDA_SG)"
                    fi
                  fi
                done
                echo "   Subnets:"
                echo "$LAMBDA_SUBNETS" | while read SUBNET; do
                  if [ -n "$SUBNET" ]; then
                    echo "     - $SUBNET"
                  fi
                done
                echo ""
                
                echo "2Ô∏è‚É£  Verificando DATABASE_URL:"
                DATABASE_URL=$(aws lambda get-function-configuration \
                  --function-name "$LAMBDA_FUNCTION" \
                  --query 'Environment.Variables.DATABASE_URL' \
                  --output text 2>/dev/null || echo "")
                
                if [ -n "$DATABASE_URL" ] && [ "$DATABASE_URL" != "None" ]; then
                  DB_HOST=$(echo "$DATABASE_URL" | sed -n 's/.*@\([^:]*\):.*/\1/p')
                  DB_PORT=$(echo "$DATABASE_URL" | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
                  echo "   ‚úÖ DATABASE_URL configurado"
                  echo "   Host: $DB_HOST"
                  echo "   Puerto: $DB_PORT"
                  
                  if echo "$DB_HOST" | grep -q "\.rds\.amazonaws\.com"; then
                    echo "   ‚úÖ Hostname es un endpoint de RDS"
                  else
                    echo "   ‚ö†Ô∏è  Hostname NO parece ser un endpoint de RDS"
                  fi
                  
                  # Verificar que RDS est√© en el mismo VPC
                  if [ -n "$LAMBDA_VPC_ID" ] && [ "$LAMBDA_VPC_ID" != "null" ]; then
                    RDS_VPC=$(aws rds describe-db-instances \
                      --query "DBInstances[?contains(Endpoint.Address, \`$DB_HOST\`)].DBSubnetGroup.VpcId" \
                      --output text 2>/dev/null | head -1 || echo "")
                    
                    if [ -n "$RDS_VPC" ] && [ "$RDS_VPC" != "null" ]; then
                      if [ "$LAMBDA_VPC_ID" == "$RDS_VPC" ]; then
                        echo "   ‚úÖ Lambda y RDS est√°n en el mismo VPC ($LAMBDA_VPC_ID)"
                      else
                        echo "   ‚ùå Lambda y RDS est√°n en VPCs diferentes"
                        echo "      Lambda VPC: $LAMBDA_VPC_ID"
                        echo "      RDS VPC: $RDS_VPC"
                      fi
                    fi
                  fi
                else
                  echo "   ‚ùå DATABASE_URL NO est√° configurado"
                fi
                echo ""
                
                echo "3Ô∏è‚É£  Logs de CloudWatch (√∫ltimos errores):"
                LOG_GROUP="/aws/lambda/$LAMBDA_FUNCTION"
                if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text 2>/dev/null | grep -q "$LOG_GROUP"; then
                  echo "   Buscando errores relacionados con base de datos..."
                  aws logs tail "$LOG_GROUP" --since 10m --format short 2>/dev/null | \
                    grep -i -E "error|database|connection|timeout|ECONNREFUSED|ENOTFOUND|Failed query|getaddrinfo" | \
                    tail -20 || echo "   No se encontraron errores espec√≠ficos"
                else
                  echo "   ‚ö†Ô∏è  No se encontr√≥ el log group"
                fi
                echo ""
                
                echo "4Ô∏è‚É£  Verificando Security Groups (confirmaci√≥n final):"
                
                echo "   Lambda SG ($LAMBDA_SG) - Reglas de salida al 5432:"
                aws ec2 describe-security-groups \
                  --group-ids $LAMBDA_SG \
                  --query 'SecurityGroups[0].IpPermissionsEgress[?FromPort==`5432` && ToPort==`5432`]' \
                  --output json 2>/dev/null | jq '.' || echo "   Error al verificar"
                
                echo "   RDS SG ($RDS_SG) - Reglas de entrada en 5432:"
                aws ec2 describe-security-groups \
                  --group-ids $RDS_SG \
                  --query 'SecurityGroups[0].IpPermissions[?FromPort==`5432` && ToPort==`5432`]' \
                  --output json 2>/dev/null | jq '.' || echo "   Error al verificar"
                
                echo ""
                echo "üìã Acciones recomendadas:"
                echo "   1. Revisa los logs de CloudWatch para ver el error exacto"
                echo "   2. Verifica que DATABASE_URL tenga las credenciales correctas"
                echo "   3. Aseg√∫rate de que RDS est√© en el mismo VPC que Lambda"
                echo "   4. Verifica que las subnets de Lambda tengan acceso a RDS"
                exit 1
                fi
              fi
            else
              echo "‚ùå Error HTTP $HTTP_CODE al verificar conexi√≥n"
              echo "Respuesta: $BODY"
              
              # Si es error 500, probablemente es problema de Security Groups
              if [ "$HTTP_CODE" == "500" ]; then
                ERROR_MSG=$(echo "$BODY" | jq -r '.error' 2>/dev/null || echo "")
                if echo "$ERROR_MSG" | grep -q "Failed query\|timeout\|ECONNREFUSED"; then
                  echo ""
                  echo "üî¥ Error 500 detectado - Probablemente problema de Security Groups"
                  echo "   Verifica que Lambda pueda conectarse a RDS configurando los Security Groups"
                fi
              fi
              
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚è≥ Reintentando en $RETRY_DELAY segundos..."
                sleep $RETRY_DELAY
              else
                echo ""
                echo "‚ùå No se pudo verificar la conexi√≥n despu√©s de $MAX_RETRIES intentos"
                echo ""
                echo "üîç Acciones recomendadas:"
                echo "   1. Configura RDS_SECURITY_GROUP_ID en los secrets de GitHub"
                echo "   2. O configura manualmente los Security Groups"
                echo "   3. Revisa los logs de CloudWatch para m√°s detalles"
                exit 1
              fi
            fi
          done

      - name: Verificar/Crear base de datos
        env:
          DATABASE_HOST: ${{ secrets.DATABASE_HOST }}
          DATABASE_USER: ${{ secrets.DATABASE_USER }}
          DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          DATABASE_NAME: ${{ secrets.DATABASE_NAME }}
        run: |
          echo "üîç Verificando si la base de datos '${{ secrets.DATABASE_NAME }}' existe..."
          echo ""
          echo "‚ö†Ô∏è  NOTA: RDS est√° en una VPC privada, por lo que no podemos conectarnos directamente desde GitHub Actions."
          echo "   La base de datos debe crearse manualmente o mediante Terraform."
          echo ""
          echo "üìã Para crear la base de datos manualmente:"
          echo ""
          echo "   1. Con√©ctate a una instancia EC2 en la misma VPC, o"
          echo "   2. Usa AWS Systems Manager Session Manager, o"
          echo "   3. Ejecuta desde tu m√°quina local con VPN/Bastion:"
          echo ""
          echo "   PGPASSWORD='${{ secrets.DATABASE_PASSWORD }}' psql \\"
          echo "     -h ${{ secrets.DATABASE_HOST }} \\"
          echo "     -U ${{ secrets.DATABASE_USER }} \\"
          echo "     -d postgres \\"
          echo "     -c \"CREATE DATABASE ${{ secrets.DATABASE_NAME }};\""
          echo ""
          echo "   4. O agrega la creaci√≥n de la base de datos en tu c√≥digo de Terraform"
          echo ""
          echo "‚úÖ Continuando con las migraciones (asumiendo que la base de datos existe o se crear√°)..."

      - name: Ejecutar migraciones de base de datos
        env:
          DATABASE_URL: postgresql://${{ secrets.DATABASE_USER }}:${{ secrets.DATABASE_PASSWORD }}@${{ secrets.DATABASE_HOST }}:5432/${{ secrets.DATABASE_NAME }}
        run: |
          echo "üîÑ Ejecutando migraciones de base de datos..."
          npm run db:push
          echo "‚úÖ Migraciones completadas"
          
          # Verificar nuevamente despu√©s de las migraciones
          echo "üîç Verificando conexi√≥n despu√©s de las migraciones..."
          API_URL="${{ steps.get-api-url.outputs.api_url }}"
          sleep 5
          
          RESPONSE=$(curl -s "$API_URL/api/db-check" || echo "")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success' 2>/dev/null || echo "false")
          TABLES_EXIST=$(echo "$RESPONSE" | jq -r '.tablesExist' 2>/dev/null || echo "false")
          
          if [ "$SUCCESS" == "true" ] && [ "$TABLES_EXIST" == "true" ]; then
            echo "‚úÖ Base de datos conectada y tablas disponibles"
          elif [ "$SUCCESS" == "true" ]; then
            echo "‚ö†Ô∏è  Base de datos conectada pero las tablas a√∫n no existen"
            echo "   Esto puede ser normal si las migraciones est√°n en progreso"
          else
            echo "‚ùå Error en la conexi√≥n despu√©s de las migraciones"
            echo "$RESPONSE" | jq '.'
            exit 1
          fi
